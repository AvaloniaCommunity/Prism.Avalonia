using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Prism.Avalonia.Toolkit;

/// <summary>Source generator for notifiable property.</summary>
[Generator(LanguageNames.CSharp)]
public partial class NotifyableGenerator
{
    private const string NotifyableAttribute = "Prism.Avalonia.Generators.NotifyableAttribute";

    private const string NotifyableAttributeCode = """
// Copyright (c) 2024 .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System;

// <auto-generated/>
#pragma warning disable
#nullable enable
namespace Prism.Avalonia.Toolkit.NotifyableGenerator;

/// <summary>NotifyableAttribute.</summary>
/// <seealso cref="Attribute" />
[global::System.CodeDom.Compiler.GeneratedCode("Prism.Avalonia.Toolkit.NotifyableGenerator.IViewForGenerator", "1.1.0.0")]
[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
public sealed class NotifyableAttribute : Attribute;
#nullable restore
#pragma warning restore
""";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(callback =>
        callback.AddSource($"{NotifyableAttribute}.g.cs", SourceText.From(NotifyableAttribute, Encoding.UTF8)));
        //callback.AddSource($"{NotifyableAttribute}.g.cs", SourceText.From(AttributeDefinitions.NotifyableAttribute, Encoding.UTF8)));

        // Gather info
        IncrementalValuesProvider<(HierarchyInfo Hierarchy, Result<PropertyInfo> Info) > propertyInfoWithErrors =
            context.SyntaxProvider
            .ForAttributeWithMetadataName(
                NotifyableAttribute,
                static (node, _) => node is VariableDeclaratorSyntax { Parent: VariableDeclarationSyntax { Parent: FieldDeclarationSyntax { Parent: ClassDeclarationSyntax or RecordDeclarationSyntax, AttributeLists.Count: > 0 } } },
                static (context, token) =>
                {
                    var fieldDeclaration = (FieldDeclarationSyntax)context.TargetNode.Parent!.Parent!;
                    var fieldSymbol = (IFieldSymbol)context.TargetSymbol;

                    // Get the hierarchy info for the target symbol, and try to gather the property info
                    var hierarchy = HierarchyInfo.From(fieldSymbol.ContainingType);

                    token.ThrowIfCancellationRequested();

                    Execute.GetFieldInfoFromClass(fieldDeclaration, fieldSymbol, context.SemanticModel, token, out var propertyInfo, out var diagnostics);

                    token.ThrowIfCancellationRequested();
                    return (Hierarchy: hierarchy, new Result<PropertyInfo?>(propertyInfo, diagnostics));
                })
            .Where(static item => item.Hierarchy is not null)!;

    }

    /// <summary>
    /// A model representing a value and an associated set of diagnostic errors.
    /// </summary>
    /// <typeparam name="TValue">The type of the wrapped value.</typeparam>
    /// <param name="Value">The wrapped value for the current result.</param>
    /// <param name="Errors">The associated diagnostic errors, if any.</param>
    internal sealed record Result<TValue>(TValue Value, EquatableArray<DiagnosticInfo> Errors)
        where TValue : IEquatable<TValue>?;

    /// <summary>
    /// A model describing the hierarchy info for a specific type.
    /// </summary>
    /// <param name="FilenameHint">The filename hint for the current type.</param>
    /// <param name="MetadataName">The metadata name for the current type.</param>
    /// <param name="Namespace">Gets the namespace for the current type.</param>
    /// <param name="Hierarchy">Gets the sequence of type definitions containing the current type.</param>
    internal sealed partial record HierarchyInfo(string FilenameHint, string MetadataName, string Namespace, EquatableArray<TypeInfo> Hierarchy)
    {
        /// <summary>
        /// Creates a new <see cref="HierarchyInfo"/> instance from a given <see cref="INamedTypeSymbol"/>.
        /// </summary>
        /// <param name="typeSymbol">The input <see cref="INamedTypeSymbol"/> instance to gather info for.</param>
        /// <returns>A <see cref="HierarchyInfo"/> instance describing <paramref name="typeSymbol"/>.</returns>
        public static HierarchyInfo From(INamedTypeSymbol typeSymbol)
        {
            using var hierarchy = ImmutableArrayBuilder<TypeInfo>.Rent();

            for (var parent = typeSymbol;
                 parent is not null;
                 parent = parent.ContainingType)
            {
                hierarchy.Add(new TypeInfo(
                    parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                    parent.TypeKind,
                    parent.IsRecord));
            }

            return new(
                typeSymbol.GetFullyQualifiedMetadataName(),
                typeSymbol.MetadataName,
                typeSymbol.ContainingNamespace.ToDisplayString(new(typeQualificationStyle: NameAndContainingTypesAndNamespaces)),
                hierarchy.ToImmutable());
        }
    }
}
